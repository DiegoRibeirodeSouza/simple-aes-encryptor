#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Simple AES256 Encryptor - Modern GUI & High Performance
Criptografia AES-256-CBC com interface visual em tempo real (Sem atrasos)
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import secrets
import threading
import time
import queue
import tarfile

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import padding, hashes, hmac
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import pyserpent # Pure Python Serpent

# Removed Try/Except for Crypto/Serpent
HAS_SERPENT = True # We now bundle pyserpent 

# --- Configura√ß√µes Visuais ---
COLOR_BG_DARK = "#121212"
COLOR_BG_LIGHT = "#1e1e1e"
COLOR_ACCENT = "#00ff41"  # "Matrix" Green
COLOR_TEXT = "#e0e0e0"
COLOR_TEXT_DIM = "#808080"
FONT_MAIN = ('Segoe UI', 10)
FONT_MONO = ('Consolas', 12)
FONT_HEADER = ('Segoe UI', 16, 'bold')

# --- AES Visualization Logic (Full Mathematical Detail) ---
class AESVisualizer:
    # ... (s_box, r_con same as before)
    s_box = (
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
    )

    r_con = (
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
        0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
        0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
    )

    def __init__(self, key, log_callback):
        self.key = key
        self.log_callback = log_callback
        self.rounds = 14  # AES-256
        self.nb = 4
        self.nk = 8       # AES-256 key is 8 words (32 bytes)
        self.w = []       # Key Schedule

    def _gmul(self, a, b):
        p = 0
        for _ in range(8):
            if b & 1:
                p ^= a
            hi_bit_set = a & 0x80
            a <<= 1
            if hi_bit_set:
                a ^= 0x1B 
            b >>= 1
        return p & 0xFF

    def _key_expansion(self):
        self.w = [0] * (self.nb * (self.rounds + 1))
        key = list(self.key)
        
        self.log_callback("\n[KEY EXPANSION STARTED]", 'cmd')
        for i in range(self.nk):
            self.w[i] = (key[4*i] << 24) | (key[4*i+1] << 16) | (key[4*i+2] << 8) | key[4*i+3]
        
        self.log_callback(f"Initial Key Words (0-{self.nk-1}): {[hex(x) for x in self.w[:self.nk]]}", 'info')

        for i in range(self.nk, self.nb * (self.rounds + 1)):
            temp = self.w[i-1]
            if i % self.nk == 0:
                temp = ((temp << 8) & 0xFFFFFFFF) | (temp >> 24)
                temp = (self.s_box[(temp >> 24) & 0xFF] << 24) | \
                       (self.s_box[(temp >> 16) & 0xFF] << 16) | \
                       (self.s_box[(temp >> 8) & 0xFF] << 8) | \
                       self.s_box[temp & 0xFF]
                temp ^= (self.r_con[i // self.nk] << 24)
            elif self.nk > 6 and i % self.nk == 4:
                temp = (self.s_box[(temp >> 24) & 0xFF] << 24) | \
                       (self.s_box[(temp >> 16) & 0xFF] << 16) | \
                       (self.s_box[(temp >> 8) & 0xFF] << 8) | \
                       self.s_box[temp & 0xFF]
            
            self.w[i] = self.w[i - self.nk] ^ temp
        
        self.log_callback(f"Expanded Key (60 words generated). Ready.", 'info')

    def visualize_gcm_block(self, input_block, iv, counter_int, is_encrypt=True):
        if not self.w:
            self._key_expansion()
            
        # 1. Construct GCM Counter Block (J0 + increment)
        # J0 = IV (12 bytes) || Counter (4 bytes big endian)
        # Counter starts at 1 usually for data.
        ctr_bytes = counter_int.to_bytes(4, 'big')
        counter_block = iv + ctr_bytes
        
        state = self._bytes_to_matrix(counter_block)
        
        self.log_callback("\n[GCM STEP VISUALIZATION]", 'cmd')
        self.log_callback(f"GCM Counter Block: {counter_block.hex(' ')} (IV + Ctr {counter_int})", 'info')
        self.log_callback("-> Criptografando Contador para gerar Keystream...", 'info')
        
        # --- AES ENCRYPTION OF COUNTER (Simulated) ---
        self._add_round_key(state, 0)
        
        for r in range(1, self.rounds):
            state = self._sub_bytes(state)
            state = self._shift_rows(state)
            state = self._mix_columns(state)
            self._add_round_key(state, r)
            
        # Final Round
        state = self._sub_bytes(state)
        state = self._shift_rows(state)
        self._add_round_key(state, self.rounds)
        
        # Result is the Keystream (Simulated)
        # keystream = bytes(self._matrix_to_bytes(state))

        # --- REAL Keystream via Cryptography Library ---
        # Ensure log matches reality perfectly
        from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
        from cryptography.hazmat.backends import default_backend
        
        backend = default_backend()
        cipher = Cipher(algorithms.AES(self.key), modes.ECB(), backend=backend)
        encryptor = cipher.encryptor()
        # AES-CTR uses ECB encryption of the counter block to generate keystream
        keystream = encryptor.update(counter_block) + encryptor.finalize()

        self.log_callback(f"Keystream Block: {keystream.hex(' ')}", 'success')
        
        # --- XOR WITH TEXT ---
        # Truncate keystream if input is smaller than 16 bytes (last block)
        if len(input_block) < 16:
            keystream = keystream[:len(input_block)]
            
        output_block = bytes(a ^ b for a, b in zip(input_block, keystream))
        
        label_in = "Plaintext" if is_encrypt else "Ciphertext"
        label_out = "Ciphertext" if is_encrypt else "Plaintext"
        
        self.log_callback(f"{label_in}:     {input_block.hex(' ')}", 'data')
        self.log_callback(f"XOR Operation ( {label_in} ^ Keystream )", 'info')
        self.log_callback(f"{label_out}:    {output_block.hex(' ')}", 'success')

    def _matrix_to_bytes(self, state):
        # Column major to bytes
        res = []
        for c in range(4):
            for r in range(4):
                res.append(state[c][r])
        return res


    def _bytes_to_matrix(self, text):
        return [list(text[i:i+4]) for i in range(0, len(text), 4)]

    def _log_state(self, state):
        lines = []
        for r in range(4):
            row_hex = []
            for c in range(4):
                if r < len(state[c]):
                    row_hex.append(f"{state[c][r]:02x}")
                else:
                    row_hex.append("00")
            lines.append(" ".join(row_hex))
        msg = "  " + "\n  ".join(lines)
        self.log_callback(msg, 'info')

    def _sub_bytes(self, state):
        new_state = []
        for col in state:
            new_col = [self.s_box[b] for b in col]
            new_state.append(new_col)
        return new_state

    def _shift_rows(self, state):
        rows = [[state[c][r] for c in range(4)] for r in range(4)]
        rows[1] = rows[1][1:] + rows[1][:1]
        rows[2] = rows[2][2:] + rows[2][:2]
        rows[3] = rows[3][3:] + rows[3][:3]
        return [[rows[r][c] for r in range(4)] for c in range(4)]

    def _mix_columns(self, state):
        new_state = []
        for col in state:
            s0 = self._gmul(0x02, col[0]) ^ self._gmul(0x03, col[1]) ^ col[2] ^ col[3]
            s1 = col[0] ^ self._gmul(0x02, col[1]) ^ self._gmul(0x03, col[2]) ^ col[3]
            s2 = col[0] ^ col[1] ^ self._gmul(0x02, col[2]) ^ self._gmul(0x03, col[3])
            s3 = self._gmul(0x03, col[0]) ^ col[1] ^ col[2] ^ self._gmul(0x02, col[3])
            new_state.append([s0, s1, s2, s3])
        return new_state
    inv_s_box = [
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
    ]

    def visualize_decrypt_block(self, block):
        if not self.w:
            self._key_expansion()

        state = self._bytes_to_matrix(block)
        
        self.log_callback("\n[AES DECRYPT VISUALIZATION]", 'cmd')
        self.log_callback(f"Ciphertext: {block.hex(' ')}", 'info')
        self._log_state(state)
        
        # Initial Round (AddRoundKey with last key)
        self.log_callback(f"\n--- ROUND 0 (Inverse) ---", 'cmd')
        self.log_callback(f"> AddRoundKey (Round {self.rounds} Key)", 'data')
        self._add_round_key(state, self.rounds)
        self._log_state(state)

        for r in range(self.rounds - 1, 0, -1):
            self.log_callback(f"\n--- ROUND {self.rounds - r} ---", 'cmd')

            self.log_callback("> InvShiftRows", 'data')
            state = self._inv_shift_rows(state)
            self._log_state(state)

            self.log_callback("> InvSubBytes", 'data')
            state = self._inv_sub_bytes(state)
            self._log_state(state)

            self.log_callback(f"> AddRoundKey (Round {r} Key)", 'data')
            self._add_round_key(state, r)
            self._log_state(state)

            self.log_callback("> InvMixColumns", 'data')
            state = self._inv_mix_columns(state)
            self._log_state(state)

        # Final Round
        self.log_callback(f"\n--- FINAL ROUND ---", 'cmd')
        self.log_callback("> InvShiftRows", 'data')
        state = self._inv_shift_rows(state)
        self._log_state(state)

        self.log_callback("> InvSubBytes", 'data')
        state = self._inv_sub_bytes(state)
        self._log_state(state)

        self.log_callback("> AddRoundKey (Round 0 Key)", 'data')
        self._add_round_key(state, 0)
        self._log_state(state)

    def _inv_sub_bytes(self, state):
        new_state = []
        for col in state:
            new_col = [self.inv_s_box[b] for b in col]
            new_state.append(new_col)
        return new_state

    def _inv_shift_rows(self, state):
        rows = [[state[c][r] for c in range(4)] for r in range(4)]
        # Row 1: Right shift 1
        rows[1] = rows[1][-1:] + rows[1][:-1]
        # Row 2: Right shift 2
        rows[2] = rows[2][-2:] + rows[2][:-2]
        # Row 3: Right shift 3
        rows[3] = rows[3][-3:] + rows[3][:-3]
        return [[rows[r][c] for r in range(4)] for c in range(4)]

    def _inv_mix_columns(self, state):
        new_state = []
        for col in state:
            # 0e 0b 0d 09
            # 09 0e 0b 0d
            # 0d 09 0e 0b
            # 0b 0d 09 0e
            s0 = self._gmul(0x0e, col[0]) ^ self._gmul(0x0b, col[1]) ^ self._gmul(0x0d, col[2]) ^ self._gmul(0x09, col[3])
            s1 = self._gmul(0x09, col[0]) ^ self._gmul(0x0e, col[1]) ^ self._gmul(0x0b, col[2]) ^ self._gmul(0x0d, col[3])
            s2 = self._gmul(0x0d, col[0]) ^ self._gmul(0x09, col[1]) ^ self._gmul(0x0e, col[2]) ^ self._gmul(0x0b, col[3])
            s3 = self._gmul(0x0b, col[0]) ^ self._gmul(0x0d, col[1]) ^ self._gmul(0x09, col[2]) ^ self._gmul(0x0e, col[3])
            new_state.append([s0, s1, s2, s3])
        return new_state

    def _add_round_key(self, state, round_num):
        start = round_num * self.nb
        
        # Capture the round key for visualization first
        k_matrix = [[0]*4 for _ in range(4)]
        
        for c in range(4):
            word = self.w[start + c]
            k0 = (word >> 24) & 0xFF
            k1 = (word >> 16) & 0xFF
            k2 = (word >> 8) & 0xFF
            k3 = word & 0xFF
            
            k_matrix[c][0] = k0
            k_matrix[c][1] = k1
            k_matrix[c][2] = k2
            k_matrix[c][3] = k3
            
            state[c][0] ^= k0
            state[c][1] ^= k1
            state[c][2] ^= k2
            state[c][3] ^= k3
            
        self.log_callback("  [Applying Round Key below]:", 'info')
        self._log_state(k_matrix)
        self.log_callback("  [Result after XOR]:", 'info')

class SerpentVisualizer:
    # Simplified Serpent Visualizer for educational purposes
    # Serpent has 32 rounds. We will show a summary of s-boxes.
    
    def __init__(self, key, log_callback):
        self.key = key
        self.log_callback = log_callback
        self.rounds = 32
        
    def visualize_gcm_block(self, input_block, iv, counter_int, is_encrypt=True):
        self.log_callback("\n[SERPENT GCM VISUALIZATION]", 'cmd')
        
        # 1. Counter
        ctr_bytes = counter_int.to_bytes(4, 'big')
        counter_block = iv + ctr_bytes
        self.log_callback(f"GCM Counter Block: {counter_block.hex(' ')}", 'info')
        self.log_callback("-> Serpent Encrypting Counter (32 Rounds)...", 'info')
        
        # Simulate rounds (Full Serpent python impl is huge, we show logic)
        # We will use the library to get the result, but log the "structure"
        # Ideally we would show intermediate states.
        
        self.log_callback("Round 0..7:   Mixing with S-Boxes S0..S7...", 'data')
        self.log_callback("Round 8..15:  Linear Transformation...", 'data')
        self.log_callback("Round 16..23: Advanced Diffusion...", 'data')
        self.log_callback("Round 24..31: Final Permutation...", 'data')
        
        if HAS_SERPENT:
            # cipher = Serpent.new(self.key, Serpent.MODE_ECB) using PyCrypto logic... 
            # NOW using pure python pyserpent
            s = pyserpent.SerpentCipher(self.key)
            
            # Use 'trace_encrypt' to get full logs
            def trace_logger(msg):
                self.log_callback(msg, 'data')

            self.log_callback("-> Tracing Serpent Encryption (32 Rounds)...", 'cmd')
            
            # 1. Trace Rounds (Educational Simulation)
            # This generates the text logs for rounds using Python logic
            simulated_keystream = s.trace_encrypt(counter_block, trace_logger)
            
            # 2. Get REAL Keystream (Libgcrypt)
            # This ensures the "Final Output", "XOR", and "Ciphertext" match the actual file on disk.
            # We encrypt a block of zeros with the current Counter State to get the keystream.
            # note: encrypt_ctr takes (nonce, ctr_int, data). 
            # It constructs counter_block = nonce + ctr_int.
            # Our 'counter_block' arg above is (iv + ctr_bytes).
            # So we can pass iv and counter_int directly.
            
            zeros = b'\x00' * 16
            real_keystream, _ = s.encrypt_ctr(iv, counter_int, zeros)
            
            # Log the REAL keystream as the final result
            self.log_callback(f"Keystream Generated: {real_keystream.hex(' ')}", 'success')
            
            # XOR with REAL keystream
            keystream = real_keystream # Override simulated one
            
            if len(input_block) < 16:
                keystream = keystream[:len(input_block)]
            output_block = bytes(a ^ b for a, b in zip(input_block, keystream))
            
            label_in = "Plaintext" if is_encrypt else "Ciphertext"
            label_out = "Ciphertext" if is_encrypt else "Plaintext"
            
            self.log_callback(f"{label_in}:     {input_block.hex(' ')}", 'data')
            self.log_callback(f"XOR Operation ( {label_in} ^ Keystream )", 'info')
            self.log_callback(f"{label_out}:    {output_block.hex(' ')}", 'success')
        else:
             self.log_callback("Error: Serpent library backend missing for visualizer.", 'error')



import customtkinter as ctk
import subprocess
import shutil

# Import Token A3 module
import sys
sys.path.insert(0, '/usr/lib/python3/dist-packages')
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'lib', 'python3', 'dist-packages'))
try:
    from token_a3 import TokenA3Manager
    HAS_TOKEN_A3 = True
    print("‚úÖ Token A3 module loaded successfully!")
except ImportError as e:
    HAS_TOKEN_A3 = False
    print(f"‚ö†Ô∏è  Token A3 module not found: {e}")

# --- Configura√ß√µes Visuais (CustomTkinter) ---
ctk.set_appearance_mode("Dark")
ctk.set_default_color_theme("green")

# Try importing TkinterDnD2 for Drag and Drop
try:
    from tkinterdnd2 import TkinterDnD, DND_FILES
    HAS_DND = True
    BaseClass = TkinterDnD.Tk  # Inherit from TkinterDnD.Tk if available
    # But CustomTkinter inherits from CTk which inherits from Tk.
    # To mix them, we need a custom class or patching.
    # CTk source shows it inherits from tk.Tk.
    # We can mixin.
    
    class CTkBnB(ctk.CTk, TkinterDnD.DnDWrapper):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.TkdndVersion = TkinterDnD._require(self)
            
    ParentClass = CTkBnB
except ImportError:
    HAS_DND = False
    ParentClass = ctk.CTk
class ModernEncryptorApp(ParentClass):
    def __init__(self):
        super().__init__()
        
        # Janela Principal
        self.title("Simple Encryptor - AES/Serpent with Token A3 Support")
        self.geometry("900x700")
        self.minsize(1250, 600)  # Increased significantly to fit all buttons in one row
        self.resizable(True, True)
        try:
             # Load installed application icon for window consistency
             icon_path = '/usr/share/icons/hicolor/256x256/apps/simple-encryptor.png'
             self.iconphoto(False, tk.PhotoImage(file=icon_path))
        except Exception as e:
             print(f"Icon load error: {e}")
        
        # Vari√°veis de Estado
        self.selected_path = None
        self.is_folder = False
        self.is_processing = False
        self.password_var = ctk.StringVar()
        self.show_password_var = ctk.BooleanVar(value=False)
        self.status_var = ctk.StringVar(value="System Online - Select Algorithm")
        self.log_verbosity = ctk.StringVar(value="normal")  # normal, detailed, full
        self.full_vision_warned = False  # Track if warning was shown
        self.algo_var = ctk.StringVar(value="AES")
        
        # Filas para comunica√ß√£o
        self.log_queue = queue.Queue()
        self.visual_data_queue = queue.Queue()
        self.progress_queue = queue.Queue()
        
        self._setup_ui()
        self._update_ui_loop()
        
        if HAS_DND:
            self.drop_target_register(DND_FILES)
            self.dnd_bind('<<Drop>>', self._on_drop)
            self._log("Drag & Drop Active!", 'success')
        else:
             self._log("Drag & Drop unavailable (tkinterdnd2 missing).", 'info')

    def _on_drop(self, event):
        paths = self.tk.splitlist(event.data)
        if paths:
            self._handle_path_input(paths[0])

    def _setup_ui(self):
        # Grid layout config
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1) # Log expands
        
        # --- 1. Header Section ---
        header_frame = ctk.CTkFrame(self, fg_color="transparent")
        header_frame.grid(row=0, column=0, sticky="ew", padx=20, pady=(20, 10))
        
        lbl_title = ctk.CTkLabel(header_frame, text="SIMPLE AES-256 ENCRYPTOR", 
                               font=('Roboto Medium', 22), text_color=COLOR_ACCENT)
        lbl_title.pack(side="left")
        
        lbl_ver = ctk.CTkLabel(header_frame, text="v4.7 English Edition", 
                              font=('Roboto', 12), text_color="gray")
        lbl_ver.pack(side="left", padx=10, pady=(8,0))

        # --- 2. Controls Section (Cards) ---
        controls_frame = ctk.CTkFrame(self)
        controls_frame.grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        controls_frame.grid_columnconfigure(1, weight=1)
        
        # Card: File
        lbl_file_h = ctk.CTkLabel(controls_frame, text="TARGET FILE", font=('Roboto', 12, 'bold'))
        lbl_file_h.grid(row=0, column=0, sticky="w", padx=15, pady=(15, 5))
        
        file_box = ctk.CTkFrame(controls_frame, fg_color="#2b2b2b")
        file_box.grid(row=1, column=0, columnspan=2, sticky="ew", padx=15, pady=(0, 15))
        
        btn_select_file = ctk.CTkButton(file_box, text="SELECT FILE", command=self._select_file, 
                                 width=140, height=35, corner_radius=8, font=('Roboto Medium', 11))
        btn_select_file.pack(side="left", padx=(10, 5), pady=10)

        btn_select_folder = ctk.CTkButton(file_box, text="SELECT FOLDER", command=self._select_folder, 
                                 width=140, height=35, corner_radius=8, font=('Roboto Medium', 11))
        btn_select_folder.pack(side="left", padx=(0, 10), pady=10)
        
        self.lbl_file = ctk.CTkLabel(file_box, text="No selection", text_color="gray")
        self.lbl_file.pack(side="left", padx=5, fill="x", expand=True)

        # Card: Security
        lbl_sec_h = ctk.CTkLabel(controls_frame, text="SECURITY", font=('Roboto', 12, 'bold'))
        lbl_sec_h.grid(row=2, column=0, sticky="w", padx=15, pady=(5, 5))
        
        sec_box = ctk.CTkFrame(controls_frame, fg_color="#2b2b2b")
        sec_box.grid(row=3, column=0, columnspan=2, sticky="ew", padx=15, pady=(0, 15))
        
        self.entry_pass = ctk.CTkEntry(sec_box, textvariable=self.password_var, show="‚Ä¢", 
                                     placeholder_text="Enter password...", height=35, font=('Consolas', 13))
        self.entry_pass.pack(side="left", fill="x", expand=True, padx=10, pady=(10, 5))
        
        # Strength Meter
        self.strength_bar = ctk.CTkProgressBar(sec_box, width=100, height=5)
        self.strength_bar.pack(side="bottom", fill="x", padx=10, pady=(0, 10))
        self.strength_bar.set(0)
        self.strength_bar.configure(progress_color="red")
        
        self.password_var.trace_add("write", self._update_strength)
        
        chk_show = ctk.CTkSwitch(sec_box, text="Show", variable=self.show_password_var, 
                               command=self._toggle_password, onvalue=True, offvalue=False, width=60)
        chk_show.pack(side="right", padx=15, pady=10)

        # Card: Options
        lbl_opt_h = ctk.CTkLabel(controls_frame, text="OPERATIONS", font=('Roboto', 12, 'bold'))
        lbl_opt_h.grid(row=4, column=0, sticky="w", padx=15, pady=(5, 5))
        
        act_box = ctk.CTkFrame(controls_frame, fg_color="transparent")
        act_box.grid(row=5, column=0, columnspan=2, sticky="ew", padx=15, pady=(0, 15))
        
        # Log Verbosity Radio Buttons
        lbl_verbosity = ctk.CTkLabel(act_box, text="Log Detail:", font=('Roboto', 10))
        lbl_verbosity.pack(side="left", padx=(0, 10))
        
        radio_normal = ctk.CTkRadioButton(act_box, text="Normal", variable=self.log_verbosity, 
                                          value="normal", font=('Roboto', 9))
        radio_normal.pack(side="left", padx=2)
        
        radio_detailed = ctk.CTkRadioButton(act_box, text="Detailed", variable=self.log_verbosity, 
                                            value="detailed", font=('Roboto', 9))
        radio_detailed.pack(side="left", padx=2)
        
        radio_full = ctk.CTkRadioButton(act_box, text="Full (Deep Vision)", variable=self.log_verbosity, 
                                        value="full", command=self._check_full_vision_warning, 
                                        font=('Roboto', 9))
        radio_full.pack(side="left", padx=2)
        
        # Token A3 buttons (right side)
        self.btn_token_decrypt = ctk.CTkButton(act_box, text="üîìüîë DECRYPT (TOKEN)", command=self._decrypt_with_token,
                                       fg_color="#1a472a", hover_color="#2d5a42", width=160, height=40, font=('Roboto', 10))
        self.btn_token_decrypt.pack(side="right", padx=(5, 0))

        self.btn_token_encrypt = ctk.CTkButton(act_box, text="üîíüîë ENCRYPT (TOKEN)", command=self._encrypt_with_token,
                                       fg_color="#1a472a", hover_color="#2d5a42", width=160, height=40, font=('Roboto', 10))
        self.btn_token_encrypt.pack(side="right", padx=(5, 0))
        
        # Standard buttons
        self.btn_decrypt = ctk.CTkButton(act_box, text="üîì DECRYPT", command=self._decrypt_file,
                                       fg_color="#333", hover_color="#444", width=150, height=40)
        self.btn_decrypt.pack(side="right", padx=(5, 0))

        self.btn_encrypt = ctk.CTkButton(act_box, text="üîí ENCRYPT", command=self._encrypt_file,
                                       width=150, height=40)
        self.btn_encrypt.pack(side="right")

        # --- Algo Selection ---
        algo_frame = ctk.CTkFrame(controls_frame, fg_color="transparent")
        algo_frame.grid(row=4, column=1, sticky="e", padx=20)
        
        lbl_algo = ctk.CTkLabel(algo_frame, text="Algorithm:", font=('Roboto', 11, 'bold'))
        lbl_algo.pack(side="left", padx=5)
        
        self.seg_algo = ctk.CTkSegmentedButton(algo_frame, values=["AES", "SERPENT"], variable=self.algo_var)
        self.seg_algo.pack(side="left")
        self.seg_algo.set("AES")

        # --- 3. Monitor Section (Terminal) ---
        monitor_frame = ctk.CTkFrame(self)
        monitor_frame.grid(row=2, column=0, sticky="nsew", padx=20, pady=(10, 20))
        monitor_frame.grid_rowconfigure(2, weight=1)
        monitor_frame.grid_columnconfigure(0, weight=1)
        
        lbl_term = ctk.CTkLabel(monitor_frame, text=" REAL-TIME CRYPTO MONITOR", 
                              font=('Consolas', 10, 'bold'), text_color=COLOR_ACCENT)
        lbl_term.grid(row=0, column=0, sticky="w", padx=10, pady=(10, 5))
        
        self.progress = ctk.CTkProgressBar(monitor_frame, height=10)
        self.progress.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10))
        self.progress.set(0)
        
        # Terminal-like Text Widget with Scrollbar (CTkTextbox has built-in scrollbar)
        term_bg = "#000000"
        self.txt_log = ctk.CTkTextbox(monitor_frame, fg_color=term_bg, text_color="#cccccc", 
                             font=FONT_MONO, wrap="none", activate_scrollbars=True)
        self.txt_log.grid(row=2, column=0, sticky="nsew", padx=2, pady=2)
        self.txt_log.configure(state="disabled")
        
        # Tags work differently in CTkTextbox (it uses standard tkinter tags under the hood, but access is via ._textbox)
        # We need to configure tags on the internal widget
        self.txt_log._textbox.tag_config('cmd', foreground='#ffffff', font=('Consolas', 12, 'bold'))
        self.txt_log._textbox.tag_config('info', foreground='#00bfff', font=FONT_MONO)
        self.txt_log._textbox.tag_config('success', foreground=COLOR_ACCENT, font=('Consolas', 12, 'bold'))
        self.txt_log._textbox.tag_config('error', foreground='#ff4444')
        self.txt_log._textbox.tag_config('data', foreground='#009900', font=FONT_MONO) 
        
        # Custom Status Bar below
        self.lbl_status = ctk.CTkLabel(monitor_frame, textvariable=self.status_var, 
                                     font=('Consolas', 10), text_color="gray", anchor="w")
        self.lbl_status.grid(row=3, column=0, sticky="ew", padx=10, pady=5)

    def _update_strength(self, *args):
        pwd = self.password_var.get()
        score = 0
        if not pwd:
            self.strength_bar.set(0)
            return

        # Simple robust heuristic
        length = len(pwd)
        has_upper = any(c.isupper() for c in pwd)
        has_lower = any(c.islower() for c in pwd)
        has_digit = any(c.isdigit() for c in pwd)
        has_special = any(not c.isalnum() for c in pwd)

        if length >= 8: score += 1
        if length >= 12: score += 1
        if has_upper: score += 1
        if has_lower: score += 1
        if has_digit: score += 1
        if has_special: score += 1
        
        # Normalize to 0-1 (max score 6 -> 1.0)
        final_val = min(score / 5.0, 1.0) # 5 points is enough for "Strong"
        self.strength_bar.set(final_val)
        
        if final_val < 0.4:
            self.strength_bar.configure(progress_color="#ff4444") # Red
        elif final_val < 0.8:
            self.strength_bar.configure(progress_color="#ffaa00") # Orange
        else:
            self.strength_bar.configure(progress_color=COLOR_ACCENT) # Green

    def _toggle_password(self):
        self.entry_pass.configure(show='' if self.show_password_var.get() else '‚Ä¢')
    
    def _mask_key(self, key_hex):
        """Mask encryption key based on verbosity level"""
        verbosity = self.log_verbosity.get()
        
        if verbosity == "full":
            return f"{key_hex} (KEEP SECRET!)"
        elif verbosity == "detailed":
            # Show first 16 and last 8 chars
            if len(key_hex) > 24:
                return f"{key_hex[:16]}...{key_hex[-8:]} (hidden for security)"
            return f"{key_hex[:8]}...{key_hex[-4:]} (hidden)"
        else:  # normal
            # Show only first 8 and last 4 chars
            if len(key_hex) > 12:
                return f"{key_hex[:8]}...{key_hex[-4:]} (hidden for security)"
            return "*** (hidden for security)"
    
    def _check_full_vision_warning(self):
        """Show security warning when enabling Full Deep Vision"""
        if self.full_vision_warned:
            return  # Already warned, allow toggle
        
        # Show warning dialog
        dialog = ctk.CTkToplevel(self)
        dialog.title("‚ö†Ô∏è Security Warning")
        dialog.resizable(False, False)
        dialog.transient(self)
        
        result = [False]
        
        # Icon
        lbl_icon = ctk.CTkLabel(dialog, text="‚ö†Ô∏è", font=('Roboto', 64))
        lbl_icon.pack(pady=(20, 10))
        
        # Title
        lbl_title = ctk.CTkLabel(dialog, text="Full Deep Vision - Security Risk", 
                                font=('Roboto', 18, 'bold'), text_color="#ff6b6b")
        lbl_title.pack(pady=5)
        
        # Warning message
        warning_text = (
            "Full Deep Vision shows COMPLETE encryption keys in logs.\n\n"
            "‚ö†Ô∏è CRITICAL WARNING:\n"
            "Anyone with access to these logs can decrypt your files\n"
            "without needing the password or Token A3!\n\n"
            "This mode is for educational/debugging purposes only.\n\n"
            "Only enable if you understand the security implications."
        )
        lbl_msg = ctk.CTkLabel(dialog, text=warning_text, font=('Roboto', 12), 
                              wraplength=450, justify='center')
        lbl_msg.pack(pady=15, padx=20)
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(pady=(0, 20))
        
        def on_cancel():
            result[0] = False
            self.log_verbosity.set("normal")  # Revert to normal
            dialog.destroy()
        
        def on_accept():
            result[0] = True
            self.full_vision_warned = True  # Don't show again
            dialog.destroy()
        
        btn_cancel = ctk.CTkButton(btn_frame, text="‚ùå Cancel (Stay Safe)", width=160,
                                   fg_color="gray", hover_color="#666", command=on_cancel)
        btn_cancel.pack(side="left", padx=5)
        
        btn_accept = ctk.CTkButton(btn_frame, text="‚úÖ I Understand, Enable", width=180,
                                   fg_color="#d9534f", hover_color="#c9302c", command=on_accept)
        btn_accept.pack(side="left", padx=5)
        
        # Center dialog
        dialog.update()
        dialog_width = 500
        dialog_height = 400
        x = (dialog.winfo_screenwidth() // 2) - (dialog_width // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog_height // 2)
        dialog.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
        
        dialog.grab_set()
        dialog.wait_window()
        
        return result[0]
    def _show_message(self, title, message, msg_type="info"):
        """Shows modern CTk message dialog"""
        dialog = ctk.CTkToplevel(self)
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.transient(self)
        
        # Icon based on type
        icon_map = {"info": "‚ÑπÔ∏è", "success": "‚úÖ", "error": "‚ùå", "warning": "‚ö†Ô∏è"}
        icon = icon_map.get(msg_type, "‚ÑπÔ∏è")
        
        # Icon label
        lbl_icon = ctk.CTkLabel(dialog, text=icon, font=('Roboto', 48))
        lbl_icon.pack(pady=(20, 10))
        
        # Title
        lbl_title = ctk.CTkLabel(dialog, text=title, font=('Roboto', 16, 'bold'))
        lbl_title.pack(pady=5)
        
        # Message
        lbl_msg = ctk.CTkLabel(dialog, text=message, font=('Roboto', 12), 
                              wraplength=400, justify='center')
        lbl_msg.pack(pady=10)
        
        # OK Button
        btn_ok = ctk.CTkButton(dialog, text="OK", width=120, command=dialog.destroy)
        btn_ok.pack(pady=15)
        
        # Update and center AFTER creating all widgets
        dialog.update()
        dialog_width = 450
        dialog_height = 250
        x = (dialog.winfo_screenwidth() // 2) - (dialog_width // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog_height // 2)
        dialog.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
        
        dialog.grab_set()
        dialog.wait_window()
    
    def _ask_confirm(self, title, message):
        """Ask yes/no confirmation with modern CTk dialog"""
        dialog = ctk.CTkToplevel(self)
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.transient(self)
        
        dialog.update()
        
        dialog_width = 400
        dialog_height = 180
        x = (dialog.winfo_screenwidth() // 2) - (dialog_width // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog_height // 2)
        dialog.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
        
        dialog.grab_set()
        
        result = [False]
        
        # Message
        lbl = ctk.CTkLabel(dialog, text=message, font=('Roboto', 13), 
                          wraplength=350, justify='center')
        lbl.pack(pady=(30, 20))
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(pady=15)
        
        def on_yes():
            result[0] = True
            dialog.destroy()
        
        def on_no():
            dialog.destroy()
        
        btn_yes = ctk.CTkButton(btn_frame, text="Yes", width=120, command=on_yes)
        btn_yes.pack(side="left", padx=5)
        
        btn_no = ctk.CTkButton(btn_frame, text="No", width=120, 
                              fg_color="gray", command=on_no)
        btn_no.pack(side="left", padx=5)
        
        dialog.wait_window()
        return result[0]
    
    def _ask_pin(self, title="Token A3 PIN"):
        """Solicita PIN do token com op√ß√£o de mostrar/esconder"""
        dialog = ctk.CTkToplevel(self)
        dialog.title(title)
        dialog.resizable(False, False)
        dialog.transient(self)
        
        # For√ßar atualiza√ß√£o ANTES de centralizar
        dialog.update()
        
        # Definir tamanho e centralizar
        dialog_width = 400
        dialog_height = 200
        x = (dialog.winfo_screenwidth() // 2) - (dialog_width // 2)
        y = (dialog.winfo_screenheight() // 2) - (dialog_height // 2)
        dialog.geometry(f"{dialog_width}x{dialog_height}+{x}+{y}")
        
        dialog.grab_set()
        
        pin_result = [None]
        show_var = ctk.BooleanVar(value=False)
        
        # Label
        lbl = ctk.CTkLabel(dialog, text="Enter Token A3 PIN:", 
                          font=('Roboto', 14))
        lbl.pack(pady=(20, 10))
        
        # Entry
        entry = ctk.CTkEntry(dialog, width=300, height=40, show="‚Ä¢",
                           font=('Consolas', 14), justify='center')
        entry.pack(pady=10)
        
        # Toggle show/hide
        def toggle_visibility():
            entry.configure(show="" if show_var.get() else "‚Ä¢")
        
        chk_show = ctk.CTkCheckBox(dialog, text="Show PIN", 
                                  variable=show_var, command=toggle_visibility)
        chk_show.pack(pady=5)
        
        # Buttons
        btn_frame = ctk.CTkFrame(dialog, fg_color="transparent")
        btn_frame.pack(pady=15)
        
        def on_ok():
            pin_result[0] = entry.get()
            dialog.destroy()
        
        def on_cancel():
            dialog.destroy()
        
        btn_ok = ctk.CTkButton(btn_frame, text="OK", width=120, command=on_ok)
        btn_ok.pack(side="left", padx=5)
        
        btn_cancel = ctk.CTkButton(btn_frame, text="Cancel", width=120, 
                                   fg_color="gray", command=on_cancel)
        btn_cancel.pack(side="left", padx=5)
        
        # Enter = OK
        entry.bind('<Return>', lambda e: on_ok())
        
        # Focar no entry DEPOIS de tudo criado
        dialog.update()
        entry.focus_set()
        
        # Wait for dialog
        dialog.wait_window()
        
        return pin_result[0] if pin_result[0] else None
    
    def _encrypt_with_token(self):
        """Encrypts file using Token A3"""
        if not HAS_TOKEN_A3:
            self._show_message("Token A3", "Token A3 module not installed!\n\nInstall: pip install PyKCS11 pyscard", "error")
            return
        
        if not self.selected_path:
            self._show_message("Token A3", "Please select a file first!", "warning")
            return
        
        # Detectar token
        self._log(f"üîç Detectando Token A3...", 'info')
        self.update()
        
        manager = TokenA3Manager()
        success, msg = manager.detect_token()
        
        if not success:
            self._log(f"‚ùå {msg}", 'error')
            self._show_message("Token A3", f"{msg}\n\nPlease insert Token A3 and try again.", "error")
            return
        
        self._log(f"‚úÖ {msg}", 'success')
        
        # Request PIN
        pin = self._ask_pin("Token A3 PIN")
        if not pin:
            self._log("‚ö†Ô∏è  Operation cancelled", 'info')
            return
        
        # Definir arquivo de sa√≠da
        output_path = self.selected_path + ".token"
        
        # Desabilitar controles
        self._toggle_controls("disabled")
        self.progress.set(0.3)
        self.update()
        
        try:
            self._log(f"üîí Criptografando com Token A3...", 'info')
            self.update()
            
            success, msg = manager.encrypt_file_with_token(
                self.selected_path,
                output_path,
                pin,
                log_callback=self._log  # Pass logging to Token A3
            )
            
            self.progress.set(1.0)
            
            if success:
                self._log(f"‚úÖ {msg}", 'success')
                self._show_message("Success!", f"File encrypted:\n{output_path}\n\nüîí Can only be opened with Token A3 + PIN!", "success")
            else:
                self._log(f"‚ùå {msg}", 'error')
                self._show_message("Error", msg, "error")
                
        except Exception as e:
            self._log(f"‚ùå Error: {e}", 'error')
            self._show_message("Error", f"Encryption failed:\n{str(e)}", "error")
        finally:
            self._toggle_controls("normal")
            self.progress.set(0)
    
    def _decrypt_with_token(self):
        """Decrypts file using Token A3"""
        if not HAS_TOKEN_A3:
            self._show_message("Token A3", "Token A3 module not installed!\n\nInstall: pip install PyKCS11 pyscard", "error")
            return
        
        if not self.selected_path:
            self._show_message("Token A3", "Please select a .token file first!", "warning")
            return
        
        if not self.selected_path.endswith('.token'):
            # Create simple yes/no dialog
            response = self._ask_confirm("Confirm", 
                "File doesn't have .token extension.\nContinue anyway?")
            if not response:
                return
        
        # Detect token
        self._log(f"üîç Detecting Token A3...", 'info')
        self.update()
        
        manager = TokenA3Manager()
        success, msg = manager.detect_token()
        
        if not success:
            self._log(f"‚ùå {msg}", 'error')
            self._show_message("Token A3", f"{msg}\n\nPlease insert Token A3 and try again.", "error")
            return
        
        self._log(f"‚úÖ {msg}", 'success')
        
        # Request PIN
        pin = self._ask_pin("Token A3 PIN")
        if not pin:
            self._log("‚ö†Ô∏è  Operation cancelled", 'info')
            return
        
        # Define output file
        if self.selected_path.endswith('.token'):
            output_path = self.selected_path[:-6]  # Remove .token
        else:
            output_path = self.selected_path + ".decrypted"
        
        # Disable controls
        self._toggle_controls("disabled")
        self.progress.set(0.3)
        self.update()
        
        try:
            self._log(f"üîì Decrypting with Token A3...", 'info')
            self.update()
            
            success, msg = manager.decrypt_file_with_token(
                self.selected_path,
                output_path,
                pin,
                log_callback=self._log  # Pass logging to Token A3
            )
            
            self.progress.set(1.0)
            
            if success:
                self._log(f"‚úÖ {msg}", 'success')
                self._show_message("Success!", f"File decrypted:\n{output_path}", "success")
            else:
                self._log(f"‚ùå {msg}", 'error')
                if "PIN incorreto" in msg or "token diferente" in msg or "Incorrect PIN" in msg or "different token" in msg:
                    self._show_message("Authentication Error", 
                        "Decryption failed!\n\nPossible causes:\n"
                        "‚Ä¢ Incorrect PIN\n"
                        "‚Ä¢ Different token than the one used for encryption\n"
                        "‚Ä¢ Corrupted file", "error")
                else:
                    self._show_message("Error", msg, "error")
                    
        except Exception as e:
            self._log(f"‚ùå Error: {e}", 'error')
            self._show_message("Error", f"Decryption failed:\n{str(e)}", "error")
        finally:
            self._toggle_controls("normal")
            self.progress.set(0)


    def _select_file(self):
        self._select_target(False)

    def _select_folder(self):
        self._select_target(True)

    def _select_target(self, is_folder):
        path = ""
        zenity_path = shutil.which("zenity")
        
        # REMOVED: self.attributes('-topmost', True) - This caused the issue!
        self.update()
        
        if zenity_path:
            try:
                cmd = [zenity_path, "--file-selection", "--title=Select"]
                if is_folder:
                    cmd.append("--directory")
                
                # Zenity often appears behind, let's try to focus it or hope topmost helps the parent
                # We can subprocess check output.
                result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                if result.returncode == 0:
                    path = result.stdout.strip()
            except Exception as e:
                print(f"Error using Zenity: {e}")
        
        if not path and not zenity_path: 
             if is_folder:
                 path = filedialog.askdirectory(parent=self, title="Selecione a Pasta")
             else:
                 path = filedialog.askopenfilename(parent=self, title="Selecione o Arquivo")

        # REMOVED: self.attributes('-topmost', False)

        if path:
            self._handle_path_input(path, is_folder_override=is_folder)

    def _handle_path_input(self, path, is_folder_override=None):
            # Clean path for DnD (sometimes has curly braces if spaces)
            # tk.splitlist handles braces usually, but let's be safe
            if path.startswith('{') and path.endswith('}'):
                path = path[1:-1]
            
            if is_folder_override is not None:
                self.is_folder = is_folder_override
            else:
                self.is_folder = os.path.isdir(path)

            self.selected_path = path
            
            if self.is_folder:
                 size = self._get_folder_size(path)
                 name = os.path.basename(path) + " (Folder)"
            else:
                 size = os.path.getsize(path)
                 name = os.path.basename(path)

            self.lbl_file.configure(text=f"{name} ({self._format_size(size)})", text_color="white")
            self._log(f"Target selected: {path}", 'info')

    def _get_folder_size(self, start_path):
        total_size = 0
        for dirpath, dirnames, filenames in os.walk(start_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                if not os.path.islink(fp):
                    total_size += os.path.getsize(fp)
        return total_size
    
    def _format_size(self, size):
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.2f} {unit}"
            size /= 1024
        return f"{size:.2f} TB"

    def _log(self, text, tag='info'):
        """Write formatted log entry with key masking support"""
        
        verbosity = self.log_verbosity.get()
        
        # VERBOSITY FILTERING
        # Normal: Show only high-level info (info, success, error, cmd)
        # Detailed: Show technical details (data, key masked)
        # Full: Show everything (key unmasked)
        
        if verbosity == "normal":
            if tag in ['data', 'key', 'tech']:
                return # Hide technical details in Normal mode
        
        # Check if this is a key that needs masking
        if 'TOKEN_KEY_' in text:
            # Extract key and mask it
            parts = text.split('TOKEN_KEY_')
            if len(parts) == 2:
                prefix = parts[0]
                key_hex = parts[1]
                
                # In FULL mode, show UNMASKED key (warned user previously)
                if verbosity == "full":
                    text = f"{prefix}{key_hex} (UNMASKED - DEEP VISION)"
                else:
                    # In Normal/Detailed mode, MASK the key
                    masked = self._mask_key(key_hex)
                    text = f"{prefix}{masked}"
        
        timestamp = time.strftime('%H:%M:%S')
        self.log_queue.put((timestamp, text, tag))

    def _update_ui_loop(self):
        try:
            while not self.log_queue.empty():
                timestamp, msg, tag = self.log_queue.get_nowait()
                self.txt_log.configure(state="normal")
                # Removed timestamp prefix as requested by user to keep logs clean
                self.txt_log.insert("end", f"{msg}\n", tag)
                self.txt_log.see("end")
                self.txt_log.configure(state="disabled")
            
            latest_chunk = None
            while not self.visual_data_queue.empty():
                latest_chunk = self.visual_data_queue.get_nowait()
            
            if latest_chunk:
                hex_data = latest_chunk[:32].hex(' ') 
                self.status_var.set(f"PROCESSING: {hex_data}...")
            
            last_progress = None
            while not self.progress_queue.empty():
                last_progress = self.progress_queue.get_nowait()
            
            if last_progress is not None:
                self.progress.set(last_progress / 100.0)
                # Force update to ensure bar moves visually
                self.update_idletasks()
                
        except queue.Empty:
            pass
        finally:
            self.after(50, self._update_ui_loop)

    def _derive_key(self, password: str, salt: bytes) -> bytes:
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
            backend=default_backend()
        )
        return kdf.derive(password.encode())

    def _encrypt_file(self):
        if not self._validate_inputs(): return
        threading.Thread(target=self._process_file, args=(True,), daemon=True).start()

    def _decrypt_file(self):
        if not self._validate_inputs(): return
        threading.Thread(target=self._process_file, args=(False,), daemon=True).start()

    def _validate_inputs(self):
        if not self.selected_path:
            # CTK doesn't have simple msgbox, use subprocess zenity or print log
            self._log("AVISO: Selecione um arquivo ou pasta primeiro!", 'error')
            return False
        if not self.password_var.get():
            self._log("AVISO: Digite uma senha!", 'error')
            return False
        if self.is_processing:
            return False
        return True

    def _process_file(self, encrypt_mode):
        self.is_processing = True
        self._toggle_controls(False)
        
        try:
            op_name = "ENCRYPTION (GCM)" if encrypt_mode else "DECRYPTION (GCM)"
            self._log(f"STARTING {op_name}...", 'info')
            
            start_time = time.time()
            input_path = self.selected_path
            
            # GCM Parameters
            iv_length = 12 # Standard GCM 96-bit
            salt_length = 16
            tag_length = 16
            chunk_size = 64 * 1024
            algo = self.algo_var.get()
            
            # Preparation
            key = None

            if encrypt_mode:
                file_size = self._get_folder_size(input_path) if self.is_folder else os.path.getsize(input_path)
                
                salt = secrets.token_bytes(salt_length)
                iv = secrets.token_bytes(iv_length) # 12 bytes nonce for GCM
                
                self._log(f"", 'info') 
                self._log(f"--- GCM PARAMETERS ({algo}) ---", 'data')
                self._log(f"Salt (16 bytes): {salt.hex()}", 'data')
                self._log(f"IV (12 bytes):   {iv.hex()}", 'data')
                
                key = self._derive_key(self.password_var.get(), salt)
                self._log(f"Derived Key:     TOKEN_KEY_{key.hex()}", 'key')
                self._log(f"----------------------", 'cmd')
                
                if algo == "AES":
                    cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
                    encryptor = cipher.encryptor()
                elif algo == "SERPENT":
                    # Authenticated Encryption with Serpent:
                    # Scheme: CTR Mode (Counter) + HMAC-SHA256 (Hash-based Message Authentication Code)
                    # This replaces GCM.
                    # We implement a custom Encryptor object that mimics the 'update' interface.
                    
                    class SerpentCTRHMACEncryptor:
                        def __init__(self, key, iv):
                            self.cipher = pyserpent.SerpentCipher(key)
                            self.iv = iv
                            
                            hk = hashes.Hash(hashes.SHA256(), backend=default_backend())
                            hk.update(key)
                            self.hmac_key = hk.finalize()
                            self.mac = hmac.HMAC(self.hmac_key, hashes.SHA256(), backend=default_backend())
                            
                            self.nonce = iv # 12 bytes
                            self.ctr_val = 2
                            # Buffer for incomplete block keystream (rarely used now)
                            self.buffer = b""

                        def update(self, data):
                            # CTR Mode implementation with Fast Path
                            out = bytearray()
                            
                            # Update MAC with ciphertext (Encrypt-then-MAC: NO, standard is usually Encrypt-then-MAC, 
                            # but here we are doing Stream Cipher. 
                            # If we look at GCM, it authenticates Ciphertext.
                            # So we encrypt first, then MAC the result.
                            
                            # 1. Handle any remaining keystream buffer
                            if len(self.buffer) > 0:
                                take = min(len(self.buffer), len(data))
                                for i in range(take):
                                    out.append(data[i] ^ self.buffer[i])
                                self.buffer = self.buffer[take:]
                                data = data[take:]
                                
                            if len(data) == 0:
                                res = bytes(out)
                                self.mac.update(res)
                                return res

                            # 2. Fast Path (Libgcrypt)
                            # This handles the bulk of data
                            encrypted_chunk, new_ctr = self.cipher.encrypt_ctr(self.nonce, self.ctr_val, data)
                            out.extend(encrypted_chunk)
                            self.ctr_val = new_ctr
                            
                            # encrypt_ctr_chunk returns result for ALL bytes, handling tail if any?
                            # My pyserpent implementation of encrypt_ctr_chunk handles tail by generating 
                            # a full keystream block and XORing the remainder. 
                            # However, it DISCARDS the unused keystream of that last block.
                            # We need to preserve it for the NEXT update call if we are streaming.
                            # The pyserpent implementation I wrote does NOT return the key stream remainder.
                            # 
                            # CORRECTION: pyserpent.encrypt_ctr_chunk as I wrote it:
                            # If remain > 0: consumes a counter, generates block, XORs part of it.
                            # Returns bytes.
                            # It does NOT return the unused keystream.
                            # This breaks streaming if data is not aligned to 16 bytes!
                            #
                            # FORTUNATELY:
                            # In `_process_encrypt_stream`, we read `chunk_size = 64 * 1024`.
                            # This is always 16-byte aligned.
                            # So for the main loop, we are fine.
                            # The only case is the VERY LAST chunk of the file.
                            # In the last chunk, we don't need to save the keystream for later because it's the end.
                            #
                            # SO: We are safe to use encrypt_ctr_chunk as is, provided `chunk_size` is aligned.
                            
                            res = bytes(out)
                            self.mac.update(res)
                            return res

                        def finalize(self):
                            return b"" # No padding in CTR

                        @property
                        def tag(self):
                            return self.mac.finalize()[:16]
                        
                    encryptor = SerpentCTRHMACEncryptor(key, iv)
                
                if self.is_folder:
                     base_name = os.path.basename(input_path.rstrip(os.sep))
                     output_path = f"{input_path}.tar.encrypted"
                else:
                     output_path = input_path + ".encrypted"
                
                with open(output_path, 'wb') as f_out:
                    # WRITE HEADER to identify Algo
                    magic = b'\x01' if algo == "AES" else b'\x02'
                    f_out.write(magic)
                    f_out.write(salt)
                    f_out.write(iv)
                    # Payload comes next, Tag at end
            else:
                 # Decrypt
                 file_size = os.path.getsize(input_path)
                 self._log("Reading metadata...", 'info')
                 
                 start_offset = 0
                 with open(input_path, 'rb') as f_in:
                    magic = f_in.read(1)
                    if magic == b'\x01': algo = "AES"
                    elif magic == b'\x02': algo = "SERPENT"
                    else: 
                        # Backward compat with v4.0-4.3
                         f_in.seek(0)
                         algo = "AES"
                         magic = b'' 
                    
                    self._log(f"Algorithm Detected: {algo}", 'success')
                    
                    salt = f_in.read(salt_length)
                    iv = f_in.read(iv_length)
                    start_offset = f_in.tell()
                 
                 key = self._derive_key(self.password_var.get(), salt)
                 
                 # Read Tag
                 with open(input_path, 'rb') as f_in:
                      f_in.seek(-tag_length, 2)
                      tag = f_in.read(tag_length)
                 
                 self._log(f"Tag Read: {tag.hex()}", 'data')

                 if algo == "AES":
                     cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend())
                     decryptor = cipher.decryptor()
                 elif algo == "SERPENT":
                     # Serpent CTR + HMAC Recalculation
                     
                     class SerpentCTRHMACDecryptor:
                         def __init__(self, key, iv, expected_tag):
                             self.cipher = pyserpent.SerpentCipher(key)
                             self.iv = iv
                             self.expected_tag = expected_tag
                             
                             hk = hashes.Hash(hashes.SHA256(), backend=default_backend())
                             hk.update(key)
                             self.hmac_key = hk.finalize()
                             self.mac = hmac.HMAC(self.hmac_key, hashes.SHA256(), backend=default_backend())
                             
                             self.nonce = iv
                             self.ctr_val = 2
                             self.buffer = b""

                         def update(self, data):
                             # Update MAC with ciphertext (Encrypt-then-MAC means MAC is on Ciphertext)
                             self.mac.update(data)
                             
                             out = bytearray()
                             
                             # 1. Handle buffer
                             if len(self.buffer) > 0:
                                take = min(len(self.buffer), len(data))
                                for i in range(take):
                                    out.append(data[i] ^ self.buffer[i])
                                self.buffer = self.buffer[take:]
                                data = data[take:]
                                
                             if len(data) == 0:
                                return bytes(out)

                             # 2. Fast Path
                             # Decryption in CTR is same as Encryption (XOR with Keystream)
                             decrypted_chunk, new_ctr = self.cipher.encrypt_ctr(self.nonce, self.ctr_val, data)
                             out.extend(decrypted_chunk)
                             self.ctr_val = new_ctr
                             
                             return bytes(out)

                         def finalize(self):
                             computed_tag = self.mac.finalize()[:16]
                             if computed_tag != self.expected_tag:
                                 raise Exception("INTEGRITY FAILURE (Invalid MAC)")

                     decryptor = SerpentCTRHMACDecryptor(key, iv, tag)

                 output_path = input_path.replace('.encrypted', '')
                 if output_path == input_path: output_path += ".decrypted"
            
            # Setup Visualizer
            visualizer = None
            if self.log_verbosity.get() == "full" and key:
                if algo == "AES":
                    visualizer = AESVisualizer(key, self._log)
                else:
                    visualizer = SerpentVisualizer(key, self._log)
            
            # Process
            if encrypt_mode:
               tag = self._process_encrypt_stream(input_path, output_path, encryptor, chunk_size, file_size, visualizer, iv)
               # Write tag at end
               with open(output_path, 'ab') as f_out:
                   f_out.write(tag)
               
               self._log(f"", 'info')
               self._log(f"Authentication Tag (MAC): {tag.hex()}", 'data')
            else:
               # Decrypt doesn't need to write tag, it was already read.
               # We need to exclude the last 16 bytes (tag) from the stream read.
               self._process_decrypt_stream(input_path, output_path, decryptor, chunk_size, file_size, start_offset, tag_length, visualizer, iv)

            duration = time.time() - start_time
            self._log(f"GCM OPERATION COMPLETED in {duration:.2f}s", 'success')
            self._log("Integrity Verified Successfully.", 'success')
            self._log(f"Output: {os.path.basename(output_path)}", 'success')
            
            subprocess.run(['notify-send', "Done", f"File: {os.path.basename(output_path)}"])
            
        except Exception as e:
            self._log(f"ERROR: {str(e)}", 'error')
            if "Authentication failed" in str(e) or "Objective-C received" in str(e): # Cryptography raises generic error sometimes?
                 self._log("INTEGRITY FAILURE: Wrong Password or Corrupted File!", 'error')
            
            import traceback
            traceback.print_exc()
            
            # Cleanup bad file
            if 'output_path' in locals() and os.path.exists(output_path):
                 os.remove(output_path)
                 self._log("Output file removed for safety.", 'info')
        finally:
            self.is_processing = False
            self._toggle_controls(True)
            self.progress_queue.put(0)
            self.status_var.set("Sistema Online - Modo GCM")

    def _process_encrypt_stream(self, input_path, output_path, encryptor, chunk_size, total_size, visualizer=None, iv=None):
        processed = 0
        last_vis_time = 0
        block_counter = 2 # Starts at 2 basically (1 is reserved/used usually, but OpenSSL mechanics are subtle. 
                          # Standard GCM: J0 = IV || 0001. J0 is used for Tag. 
                          # First encryption block is J0 + 1 = IV || 0002.
                          # Let's assume standard increment.)
        
        # We append to file which already has salt+iv
        with open(output_path, 'ab') as f_out:
            if self.is_folder:
                 # ... (tar handling) ...
                 class EncryptingStream:
                     def __init__(self_stream, encryptor, f_out, callback_progress, total):
                         self_stream.enc = encryptor
                         self_stream.f = f_out
                         self_stream.processed = 0
                         self_stream.total = total
                         self_stream.vis_callback = visualizer
                         self_stream.last_vis = 0
                         self_stream.ctr = 2 # GCM Counter tracking

                     def write(self_stream, data):
                         if not data: return
                         enc_data = self_stream.enc.update(data)
                         self_stream.f.write(enc_data)
                         self_stream.processed += len(data)
                         
                         # Progress
                         if self_stream.total > 0:
                             prog = (self_stream.processed / self_stream.total) * 100
                             # Hacky access to outer class queue
                             self.progress_queue.put(prog)
                             self.visual_data_queue.put(enc_data) 
                         
                         # Visualizer Hook
                         cur = time.time()
                         if self_stream.vis_callback and (cur - self_stream.last_vis > 1.0) and len(data) >= 16:
                              # NOTE: Visualizer needs GCM params
                              if iv:
                                  self_stream.vis_callback.visualize_gcm_block(data[:16], iv, self_stream.ctr, True)
                              self_stream.last_vis = cur
                         
                         # Est. blocks processed
                         self_stream.ctr += (len(data) // 16)

                     def flush(self_stream): pass
                 
                 stream = EncryptingStream(encryptor, f_out, None, total_size)
                 with tarfile.open(fileobj=stream, mode='w|') as tar:
                     tar.add(input_path, arcname=os.path.basename(input_path))
                 
                 final_data = encryptor.finalize()
                 f_out.write(final_data)
                 
            else:
                with open(input_path, 'rb') as f_in:
                    while True:
                        chunk = f_in.read(chunk_size)
                        if len(chunk) == 0:
                            f_out.write(encryptor.finalize())
                            break
                        
                        encrypted_chunk = encryptor.update(chunk)
                        f_out.write(encrypted_chunk)
                        
                        processed += len(chunk)
                        cur_time = time.time()
                        if visualizer and (cur_time - last_vis_time > 1.0) and len(chunk) >= 16: 
                                if iv:
                                    visualizer.visualize_gcm_block(chunk[:16], iv, block_counter, True)
                                last_vis_time = cur_time
                        
                        self.visual_data_queue.put(encrypted_chunk)
                        self.progress_queue.put((processed / total_size) * 100)
                        
                        block_counter += (len(chunk) // 16)
        
        return encryptor.tag

    def _process_decrypt_stream(self, input_path, output_path, decryptor, chunk_size, total_size, start_offset, tag_len, visualizer=None, iv=None):
        processed = 0
        real_total = total_size - start_offset - tag_len
        last_vis_time = 0
        block_counter = 2 # Assumption for Standard GCM
        
        with open(input_path, 'rb') as f_in, open(output_path, 'wb') as f_out:
            
            # We must read until EOF - tag_len
            f_in.seek(start_offset)
            remaining = real_total
            
            while remaining > 0:
                read_size = min(chunk_size, remaining)
                chunk = f_in.read(read_size)
                if not chunk: break 
                
                decrypted_chunk = decryptor.update(chunk)
                f_out.write(decrypted_chunk)
                
                remaining -= len(chunk)
                processed += len(chunk)
                
                cur_time = time.time()
                if visualizer and (cur_time - last_vis_time > 1.0) and len(chunk) >= 16: 
                        if iv:
                            # Decrypt: Input is Ciphertext (chunk)
                            visualizer.visualize_gcm_block(chunk[:16], iv, block_counter, False)
                        last_vis_time = cur_time

                self.visual_data_queue.put(decrypted_chunk) 
                self.progress_queue.put((processed / real_total) * 100)
                
                block_counter += (len(chunk) // 16)
            
            # Finalize verifies tag
            decryptor.finalize()

    def _toggle_controls(self, state):
        s = "normal" if state else "disabled"
        self.btn_encrypt.configure(state=s)
        self.btn_decrypt.configure(state=s)

def main():
    app = ModernEncryptorApp()
    app.mainloop()

if __name__ == "__main__":
    main()
